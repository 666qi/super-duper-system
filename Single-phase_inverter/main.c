/*
 * main.c
 *
 *  Created on: 2025年8月28日
 *      Author: jzy
 */
//=====================================================================================================================
// 电压源模式逆变
//=====================================================================================================================
/*
 * 硬件说明
 * --------------------------------------------
 * 开发板 LAUNCHXL-F280049C 芯片特性如下：
 * TMU - 0 类
 * CLA - 2 类
 * DMA - 0 类
 *
 * 软件说明
 * --------------------------------------------
 * 参考 TI TIDM-HV-1PH-DCAC
 * 开关频率 20KHz
 *
 * 产生 PWM 波的流行调制方案包括：
 * 双极调制、单极调制、单极性倍频调制。
 *
 * 该参考设计采用了单极性倍频调制。
 * 其中开关Q1-Q4都在高频切换。
 */
//=====================================================================================================================
/*
 * 开环测试方案：
 * --------------------------------------------
 * 1、检查 4 个 MOS 管的开关波形，确保死区时间
 * 2、校准传感器偏置电压（电感电流、交流电压、直流电压）
 * 3、校准 ADC 采集值
 * 4、计算电压、电流及功率
 * 5、检查串口打印功能
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 特别注意
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 要确保电压、电流的相位与SPWM的占空比一致
 */
//=====================================================================================================================

/* ---------------------------------------------------------------
 * 在 FLASH 中存储 RAM 中运行
 * F28x_usDelay() 在 f28004x_usdelay.asm 汇编文件中
 * 并且定义在 .sect ".TI.ramfunc" 段中
 *
 * 在 FLASH 运行时，工程添加宏定义 _FLASH
 * ------------------------------------------------------------ */

//
// Included Files
//
//=====================================================================================================================


#include "F28x_Project.h"


//=====================================================================================================================
/* ------------------------------------------------------------
 * 在 CCS 编程中，如果我们不指定变量的存放位置，编译器会自动的给变量分配一个位置，
 * 但是如果有的时候需要把变量放在一个特定的空间内，我们应该如何操作呢，
 * CCS提供了如下的两个指令
 * #pragma CODE_SECTION
 * #pragma DATA_SECTION
 *
 * 其中data_section是针对数据空间的
 *     code_section是针对程序空间的
 * ------------------------------------------------------------*/
// #pragma DATA_SECTION(myADCADataBuffer, "ramgs0");  // ramgs0 在 cmd 文件中定义
// #pragma DATA_SECTION(myADCCDataBuffer, "ramgs0");  // ramgs0 在 cmd 文件中定义

//=====================================================================================================================

// ----------------------------------------------------------------------
// 全局变量
// ----------------------------------------------------------------------
float32_t debugfloat;    // 调试
uint16_t  debugarry[4];  // 调试

//VOFA+打印变量声明

extern float32_t Nomalization;
extern int16_t CMP1,CMP2;
extern float32_t Vref;
extern float32_t Vdref;
extern float32_t Vqref;
extern float32_t Idref;
extern float32_t Idref1;
extern float32_t Iqref;
extern float32_t Iref;
extern float32_t err;
extern float32_t errV;
extern float32_t x1;
extern float32_t Vd1ref,Vq1ref;
extern float32_t phase_error;
extern float32_t new_y_alpha_V;


// 主函数入口
void main(void)
{
    //
    // Step 1. 系统控制初始化:
    // 初始化PLL锁相环、看门狗、使能外设时钟
    // 此函数位于f28004x_sysctrl.c文件中
    // 初始化后系统主频为100MHz，并开启所有外设时钟
    //=======================================================================
    InitSysCtrl();//主频 100M 并开启所有外设的时钟

    //
    // Step 2. 硬件初始化:
    // 初始化开发板上的外设电路和调试接口
    //=======================================================================
    InitBoard();   // 对使用的硬件电路初始化(如GPIO、外设等)
    InitDebug();   // 初始化调试串口（使用SCIA端口）

    // Step 2.1. CPU定时器初始化与配置:
    // 系统主频 = 100MHz
    // 初始化三个CPU定时器并设置不同频率
    //=========================================================================
    InitCpuTimers();                         // 初始化所有CPU定时器
    ConfigCpuTimer(&CpuTimer0, 100, 1000);   // 配置定时器0为1kHz (周期1ms)
    ConfigCpuTimer(&CpuTimer1, 100, 10000);  // 配置定时器1为100Hz (周期10ms)
    ConfigCpuTimer(&CpuTimer2, 100, 100000); // 配置定时器2为10Hz (周期100ms)

    // 启动定时器2
    EALLOW;
    CpuTimer2Regs.TCR.bit.TSS = 0;    // 启动定时器2
    EDIS;


    //
    // Step 3. 中断系统初始化:
    // 禁用CPU中断，初始化PIE控制器和中断向量表
    //=========================================================================
    DINT;                  // 禁用全局中断

    // 初始化PIE控制寄存器到默认状态（所有PIE中断禁用，标志位清零）
    InitPieCtrl();

    IER = 0x0000;              // 禁用CPU级别中断
    IFR = 0x0000;              // 清除所有CPU中断标志

    InitPieVectTable();        // 初始化PIE中断向量表

    // Step 3.1. 用户中断配置:
    // 配置特定的CPU和PIE中断
    //=========================================================================
    IER |= M_INT1;               // 使能CPU级别INT1中断（对应PIE组1）

    PieCtrlRegs.PIEIER1.bit.INTx1 = 1;      // 使能PIE组1中的第1个中断（ADCA1中断）
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // 清除PIE组1的中断应答位，允许接收新中断

    // Step 3.2. 全局中断使能:
    // 使能全局中断和实时调试事件
    //=========================================================================
    EINT;                     // 使能全局中断
    ERTM;                    // 使能实时调试事件

    // Step 4. 用户代码初始化:

    // Step 4.1.初始化应用程序所需的全局变量和资源
    //=========================================================================
    InitGlobalVariable();  // 初始化全局变量

    // Step 4.2. PID 参数初始化:
    //==============================================
    // -----------------------------------------
    // 1、初始化 电压环的 PI 参数
    // 2、初始化 电流环的 PI 参数
    // 3、初始化 电压外环 电流内环 的 PI 参数
    // 4、初始化 延时锁相环的 PI 相关参数
    // 5、初始化 SOGI锁相环的 PI 相关参数
    // -----------------------------------------
    //==============================================


    // -------------------------------------
    // 1、初始化 电压环 的 PI 参数
    // -------------------------------------
    /*
     * Kp 0.0128f
     * Ki 30.00f
     * PI 输出最大值       40
     * PI 输出最小大值     -40
     * 当前误差值初始值    0.0f
     * 上一次误差值初始值  0.0f
     * 当前输出值初始值    0.0f
     * 上一次输出值初始值  0.0f
     */
    // -------------------------------------
    #if(loop_mode == Voltage_loop)


      Init_Voltage_Loop_PID(0.32f,20.0f,40.0f,-40.0f, 0.0f, 0.0f,0.0f, 0.0f);

    #endif
    // -------------------------------------
    // 2、初始化 电流环 的 PI 参数
    // -------------------------------------
    /*
    * Kp 0.008f
    * Ki 10.0f
    * PI 输出最大值      1.7
    * PI 输出最小大值    -1.7
    * 当前误差值初始值    0.0f
    * 上一次误差值初始值  0.0f
    * 当前输出值初始值    0.0f
    * 上一次输出值初始值  0.0f
    */
    // -------------------------------------
    #if(loop_mode == Current_loop)

    Init_Current_Loop_PID(1.0f, 10.0f, 3.90f,-3.90f, 0.0f, 0.0f, 0.0f, 0.0f);     //归一化系数1/4

    #endif

    // -------------------------------------
    // 3、初始化 电压外环 电流内环 的 PI 参数
    // -------------------------------------
    #if(loop_mode == Dual_loop)


    Init_Voltage_Loop_PID(0.1f,30.0f,40.0f,-40.00f, 0.0f, 0.0f,0.0f, 0.0f);     //电压外环PI参数  电压环输出缩小10倍 归一化系数1/4
    Init_Current_Loop_PID(0.8f,8.0f,3.9f,-3.9f, 0.0f, 0.0f, 0.0f, 0.0f);

    #endif

    // -------------------------------------
    // 4、初始化延时锁相环的 PI 参数
    // -------------------------------------
    /* w 角频率 = 2πf 其中 f 为 50Hz
     * 二阶系统最佳工程参数 阻尼比 ξ 0.707
     * 输入电压峰值为 45.0
     * PI 输出最大值 5000
     * PI 输出最小值 -5000
     * 当前误差值初始值 0
     * 上一次当前误差值初始值 0
     */
     // ------------------------------------
     Init_PLL_PID(150,1.8, 45.0, 500.0, 100.0, 0.0f, 0.0f);

     // -------------------------------------
     // 5、初始化SOGI锁相环的 PI 参数
     // -------------------------------------
     /* 比例系数 kp=1.0：控制频率跟踪的动态响应速度
      * 积分系数 ki=50.0：消除稳态相位误差
      * 初始频率 50.0Hz：电网额定频率，内部转换为角频率
      * 误差初始化：当前和上一周期误差均清零
      */
     // ------------------------------------
     Init_SOGI_PLL(1.0f, 50.0f, 50.0f,0.0f, 00.0f);

     // Step 4.3. 其他函数初始化：
     //==============================================
     // -----------------------------------------
     // 1、初始化SOGI-αβ正交信号发生器
     // 2、初始化基于Tustin变换的传递函数离散化的SOGI正交信号发生器
     // 3、初始化基于Tustin变换的状态方程离散化的SOGI正交信号发生器
     // -----------------------------------------
     //==============================================

     #if(Phase_locked_mode == Phase_SOGI_Forward)
     // -------------------------------------
     // 1、初始化SOGI-αβ正交信号发生器
     // -------------------------------------
     // ------------------------------------
     /* 参数设置说明：
      * - 采样周期 Ts：使用系统PWM周期作为SOGI算法采样时间
      * - 阻尼系数 1.0：设置为临界阻尼状态，保证系统稳定性和响应速度
      * - 中心频率 50.0Hz：设置为电网额定频率，用于谐振点校准
      * - 功能：初始化SOGI正交信号发生器，生成αβ坐标系分量
      */
     Init_SOGI_alpha_beta(Ts, 1.0f, 50.0f);
     #endif
     #if(Phase_locked_mode == Phase_SOGI_Tustin)
     // -------------------------------------
     // 2、初始化基于传递函数法的SOGI正交信号发生器
     // -------------------------------------
     /* 参数说明：
      * &sogi     : SOGI_Tustin结构体地址
      * 50.0      : 电网标称频率50Hz
      * 20000.0   : 中断频率20kHz（采样周期50us）
      */
     // ------------------------------------
     SOGI_Tustin_config(&sogi_tustin, 50.0f, 20000.0f);
     #endif
     #if(Phase_locked_mode == Phase_SOGI_Statespace)
     // -------------------------------------
     // 3、初始化基于状态空间法的SOGI正交信号发生器
     // -------------------------------------
     /* 参数说明：
      * &sogi_statespace : SOGI_StateSpace结构体地址
      * 50.0            : 电网标称频率50Hz
      * 20000.0         : 中断频率20kHz（采样周期50us）
      */
     // ------------------------------------
     SOGI_StateSpace_config(&sogi_statespace,50.0f,20000.0f);

     #endif
     // Step 5. ePWM时钟同步启动:
     // 启动所有ePWM模块的时基时钟同步
     //=========================================================================
     EALLOW;
     CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;  // 启动所有ePWM时基时钟同步
     EDIS;


    // Step 6. 主循环:
    // 应用程序主循环，处理ADCA1中断标志并发送调试数据
    //=========================================================================
    while(1){
        // 检测ADCA1中断服务程序设置的标志位
        if(ISR_ADCA1){


            debugfloat = g_VoInst;                      // 打印交流电压数据
            sendVOFAonechannel(debugfloat,debugarry);   // 发送调试数据

            debugfloat = str_alpha_beta.wValpha;                      // 打印交流电流数据
            sendVOFAonechannel(debugfloat,debugarry);   // 发送调试数据

            debugfloat = str_alpha_beta.wVbeta;                  // 打印其他数据
            sendVOFAonechannel(debugfloat,debugarry);    // 发送调试数据

            debugfloat =str_d_q.wVq;                        // 打印其他数据
            sendVOFAonechannel(debugfloat,debugarry); // 发送调试数据

            debugfloat =g_Omega ;                 // 打印其他数据
            sendVOFAonechannel(debugfloat,debugarry); // 发送调试数据

            debugfloat = 0;                 // 打印其他数据
            sendVOFAonechannel(debugfloat,debugarry); // 发送调试数据

            debugfloat = g_Theta;                 // 打印其他数据
            sendVOFAonechannel(debugfloat,debugarry); // 发送调试数据

            sendVOFAtail();               // 发送帧尾

            ISR_ADCA1 = 0;                // 清除中断标志位
                    }

           }
}



// ---------------------------------
// End of File
// ---------------------------------

